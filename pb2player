#!/usr/bin/env python

from __future__ import with_statement

from optparse import OptionParser

option_parser = OptionParser(description = "GStreamer-based player with variable-speed playback support",
                             usage = "%prog [options] [ mediafile.ext | playlist.m3u ]", version = "%prog 1.0.1")
(prog_options, prog_args) = option_parser.parse_args()

import sys, os
import pygtk, gtk, gobject

import pygst; pygst.require("0.10")
import gst

class CallbackDict(object):
  def __init__(self):
    self.callback_dict = {}

  def add_callback(self, name, cb):
    cbs = self.callback_dict.get(name) or []
    cbs.append (cb)
    self.callback_dict [name] = cbs

  def call_callbacks(self, name, *args):
    for cb in (self.callback_dict.get(name) or []):
      ret = cb (*args)
      if ret: return ret


class PlayerModel(CallbackDict):
  def __init__(self):
    super(PlayerModel, self).__init__()
    self.filepath = None
    self.rate = 1.0
    self.playlist = []; self.playlist_idx = -1
    self.player = gst.element_factory_make("playbin2", "player")
    self.player_state = None
    self.set_player_state("STOP")
    bus = self.player.get_bus()
    bus.add_signal_watch()
    bus.connect("message", self.on_message)
    bus.enable_sync_message_emission()
    bus.connect("sync-message::element", self.on_sync_message)

  def open_file(self, filepath = None):
    if filepath is None:
      filepath = self.filepath
    else:
      self.filepath = filepath
    print "File %s" % (filepath)
    if os.path.isfile(filepath): filepath = "file://" + filepath
    self.player.set_property("uri", filepath)
    self.player.set_state(gst.STATE_PAUSED)

  def load_playlist(self, filepath):
    (pl_dir, _) = os.path.split (filepath)
    with open (filepath) as fpl:
      self.playlist = list (os.path.join (pl_dir, fn.rstrip ("\n")) for fn in fpl)
    self.playlist_idx = -1

  def playlist_jump(self, nidx):
    if nidx < 0 or nidx >= len(self.playlist): return False
    if self.player_state != "STOP": self.set_player_state("STOP")
    self.playlist_idx = nidx
    self.open_file(self.playlist [self.playlist_idx])
    return True
    
  def forward_backward(self, delta):
    if self.duration is None: return
    pos_int = self.player.query_position(gst.FORMAT_TIME, None)[0]
    self.player.seek (self.rate, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
                      gst.SEEK_TYPE_SET, pos_int + delta,
                      gst.SEEK_TYPE_NONE, -1)
  def seek_percent(self, percent):
    if self.duration is None: return
    self.player.seek (self.rate, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
                      gst.SEEK_TYPE_SET, self.duration * percent / 100.0,
                      gst.SEEK_TYPE_NONE, -1)

  def change_rate(self, rate, pos = None):
    self.rate = rate; print "Rate %s" % (self.rate)
    if self.duration is None: return
    if pos is None:
      pos = self.player.query_position(gst.FORMAT_TIME, None)[0]
    self.player.seek (self.rate, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
                      gst.SEEK_TYPE_SET, pos,
                      gst.SEEK_TYPE_NONE, -1)

  def on_message(self, bus, message):
    t = message.type
    if t == gst.MESSAGE_ASYNC_DONE:
      if self.player_state == "PLAY":
        if self.duration is None:  # 1st time only
          self.duration = self.player.query_duration (gst.FORMAT_TIME, None) [0]
          print "Duration %s" % (self.duration)
          self.change_rate (self.rate, pos = 0)
          self.player.set_state (gst.STATE_PLAYING)
    if t == gst.MESSAGE_EOS:
      self.set_player_state("STOP")
      self.call_callbacks("player-state", "STOP", "EOS")
    elif t == gst.MESSAGE_ERROR:
      err, debug = message.parse_error()
      print "Error: %s" % err, debug
      self.set_player_state("STOP")
      self.call_callbacks("player-state", "STOP", "ERR")

  def on_sync_message(self, bus, message):
    if message.structure is None: return
    message_name = message.structure.get_name()
    if message_name == "prepare-xwindow-id":
      imagesink = message.src
      imagesink.set_property("force-aspect-ratio", True)
      self.call_callbacks("set-player-xwindow-id", lambda(xid): imagesink.set_xwindow_id(xid))

  def set_player_state(self, state):
    if self.player_state == state: return
    print "player_state", state
    if state == "STOP":
      self.player.set_state(gst.STATE_NULL)
      self.duration = None
    elif state == "PLAY":
      self.player.set_state(gst.STATE_PAUSED if self.player_state == "STOP" else gst.STATE_PLAYING)
    elif state == "PAUSE":
      self.player.set_state(gst.STATE_PAUSED)
    self.player_state = state

class GTK_Main(CallbackDict):
  def __init__(self):
    super(GTK_Main, self).__init__()
    self.init_ui()

  def run(self):
    gtk.gdk.threads_init()
    gtk.main()
  def quit(self):
    gtk.main_quit()

  def set_ui_state(self, state):
    print "ui_state", state
    if state == "STOP":
      self.jump_to = None
      self.play_button.set_label(">")
      self.toggle_controls (True)
      self.pos_slider.set_value (0)
    elif state == "PLAY":
      self.play_button.set_label("||")
      self.toggle_controls (False)
    elif state == "PAUSE":
      self.play_button.set_label(">")
      self.toggle_controls (True)

  def init_ui(self):
    self.last_folder = None

    window = gtk.Window(gtk.WINDOW_TOPLEVEL)
    self.window = window
    window.set_title("Playbin Player")
    window.set_default_size(240, 240)
    window.connect("destroy", lambda *args: self.call_callbacks("destroy"))

    vbox = gtk.VBox()
    window.add(vbox)
    self.control_panel = gtk.VBox ()
    self.movie_window = gtk.DrawingArea()
    vbox.add_with_properties(self.control_panel, "expand", False)
    vbox.add_with_properties(self.movie_window, "expand", True)
    vbox = self.control_panel

    hbox = gtk.HBox()
    vbox.add (hbox)
    self.prev_button = gtk.Button("<<")
    self.prev_button.connect("clicked", lambda *args: self.call_callbacks("advance", -1))
    hbox.add_with_properties(self.prev_button, "expand", False)
    self.fname_entry = gtk.Entry(); self.fname_entry.set_property ("editable", False)
    hbox.add(self.fname_entry)
    self.open_button = gtk.Button("Open")
    self.open_button.connect("clicked", self.on_open)
    hbox.add_with_properties(self.open_button, "expand", False)
    self.play_button = gtk.Button(">")
    self.play_button.connect("clicked", lambda *args: self.call_callbacks("playpause"))
    hbox.add_with_properties(self.play_button, "expand", False)
    self.stop_button = gtk.Button("Stop")
    self.stop_button.connect("clicked", lambda *args: self.call_callbacks("stop"))
    hbox.add_with_properties(self.stop_button, "expand", False)

    self.iofn_hbox = gtk.HBox()
    hbox.add_with_properties(self.iofn_hbox, "expand", False)
    self.iofn_spin = gtk.SpinButton (gtk.Adjustment (1, 1, 10000, 1, 5, 0), 0, 0)
    self.iofn_spin.set_wrap (True)
    self.iofn_spin.connect("value-changed", self.on_iofn_changed)
    self.iofn_hbox.add_with_properties(self.iofn_spin, "expand", False)
    self.ofn_label = gtk.Label ()
    self.iofn_hbox.add_with_properties(self.ofn_label)

    self.next_button = gtk.Button(">>")
    self.next_button.connect("clicked", lambda *args: self.call_callbacks("advance", 1))
    hbox.add_with_properties(self.next_button, "expand", False)

    hbox = gtk.HBox()
    vbox.add (hbox)
    self.slow_button = gtk.Button("Slower")
    self.slow_button.connect("clicked", lambda *args: self.call_callbacks("slower"))
    hbox.add_with_properties(self.slow_button)
    self.speed1_button = gtk.Button("1x")
    self.speed1_button.connect("clicked", lambda *args: self.call_callbacks("normal_speed"))
    hbox.add(self.speed1_button)
    self.fast_button = gtk.Button("Faster")
    self.fast_button.connect("clicked", lambda *args: self.call_callbacks("faster"))
    hbox.pack_end(self.fast_button)

    hbox = gtk.HBox()
    vbox.add (hbox)
    self.on_backward_button = gtk.Button ("<-")
    self.on_backward_button.connect("clicked", lambda *args: self.call_callbacks("backward"))
    hbox.add_with_properties(self.on_backward_button, "expand", False)
    self.pos_slider = gtk.HScale (gtk.Adjustment (0.0, 0.0, 101.5, 0.5, 2.0, 1.5))
    self.pos_slider.set_update_policy(gtk.UPDATE_DISCONTINUOUS)
    self.pos_slider.connect("change-value", self.on_change_position1)
    self.pos_slider.connect("value-changed", self.on_change_position2)
    hbox.add (self.pos_slider)
    self.on_forward_button = gtk.Button ("->")
    self.on_forward_button.connect("clicked", lambda *args: self.call_callbacks("forward"))
    hbox.add_with_properties(self.on_forward_button, "expand", False)

    self.movie_window.connect("button_press_event", self.on_movie_clicked)
    self.movie_window.set_events(gtk.gdk.BUTTON_PRESS_MASK)

    self.set_ui_state("STOP")
    window.show_all()
    self.iofn_hbox.hide ()

  def provide_movie_window_xid(self, setter):
    gtk.gdk.threads_enter()
    setter(self.movie_window.window.xid)
    gtk.gdk.threads_leave()

  def on_open(self, *args):
    chooser = gtk.FileChooserDialog(title = "Open", action = gtk.FILE_CHOOSER_ACTION_OPEN,
                                    buttons = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    chooser.set_show_hidden (True)
    if (self.last_folder): chooser.set_current_folder (self.last_folder)
    filepath = None
    if chooser.run () == gtk.RESPONSE_OK:
      filepath = chooser.get_filename()
      self.last_folder = os.path.dirname(filepath)
    chooser.destroy()
    if filepath: self.call_callbacks("open", filepath)

  def playlist_mode(self, playlist_p, n = None):
    if playlist_p:
      self.ofn_label.set_text ("of " + str (n))
      self.iofn_spin.set_range (1, n)
      self.iofn_hbox.show ()
    else:
      self.iofn_hbox.hide()
  def set_iofn(self, i):
    print "set_iofn", i
    if i != self.get_iofn_pl_pos():
      self.iofn_spin.set_value (i)

  def get_iofn_pl_pos(self):
    return int (self.iofn_spin.get_value ())
  def on_iofn_changed(self, *args):
    i = self.get_iofn_pl_pos()
    self.call_callbacks("iofn_changed", i)
    return True

  def update_ui (self, pos):
    if self.jump_to is None:
      self.pos_slider.set_value (pos)

  def on_change_position1(self, *args):
    self.jump_to = self.pos_slider.get_value ()

  def on_change_position2(self, *args):
    if self.jump_to is not None:
      self.call_callbacks("seek_percent", self.jump_to)
      self.jump_to = None

  def on_movie_clicked(self, *args):
    self.toggle_controls()

  def toggle_controls(self, make_visible = None):
    if make_visible is None:
      make_visible = not self.control_panel.props.visible  # toggle
    if make_visible:
      self.control_panel.show()
      self.window.unfullscreen()
    else:
      self.control_panel.hide()
      self.window.fullscreen()

  def create_timer(self, interval, cb):
    return gobject.timeout_add_seconds (interval, cb)
  def cancel_timer(self, timer):
    gobject.source_remove(timer)

class PB2Player:
  def __init__(self, options, args):
    self.timeout = None
    self.model = PlayerModel()
    self.model.add_callback("player-state", self.on_model_state_changed)
    self.ui = GTK_Main()
    self.model.add_callback("set-player-xwindow-id", self.ui.provide_movie_window_xid)
    for m in "destroy,faster,slower,normal_speed,forward,backward,seek_percent,open,advance,iofn_changed,playpause,stop".split (","):
      self.ui.add_callback(m, getattr (self, "on_" + m))
    if len (args) > 0:
      self.open_something(os.path.abspath (args [0]))

  def run(self):
    self.ui.run()

  def on_model_state_changed(self, state, reason):
    print "player-state", state, reason
    if state == "STOP" and reason != "ERR":
      if len (self.model.playlist) > 0: self.on_advance(1)

  def update_ui (self):
    if self.model.player.get_state() [1] == gst.STATE_PLAYING:
      self.ui.update_ui(100.0 * self.model.player.query_position (gst.FORMAT_TIME, None) [0] / self.model.duration)
    return True

  def on_iofn_changed(self, i):
    i = i - 1
    if i != self.model.playlist_idx:
      print "Spun to %d" % i
      self.model.playlist_jump(i)
      self.set_app_state("PLAY")

  def on_faster(self):
    self.model.change_rate (self.model.rate * 1.1)
  def on_slower(self):
    self.model.change_rate (self.model.rate / 1.1)
  def on_normal_speed(self):
    self.model.change_rate (1.0)
  def on_forward(self):
    self.model.forward_backward(5000000000)
  def on_backward(self):
    self.model.forward_backward(-5000000000)
  def on_seek_percent(self, percent):
    self.model.seek_percent(percent)

  def on_playpause(self):
    if self.model.player_state == "PAUSE":  # unpause
      self.set_app_state("PLAY")
    elif self.model.player_state == "STOP":  # start (again)
      self.model.open_file(None)
      self.set_app_state("PLAY")
    else:  # pause
      self.set_app_state("PAUSE")
  def on_stop(self):
    self.set_app_state("STOP")

  def on_open(self):
    self.open_something(filepath)
  def open_something(self, filepath):
    if filepath [-4:] == ".m3u":
      self.model.load_playlist(filepath)
      n = len (self.model.playlist)
      self.ui.playlist_mode(True, n)
      self.on_advance(1)
    else:
      self.ui.playlist_mode(False)
      self.open_file(filepath)
      self.set_app_state("PLAY")

  def on_advance(self, delta):
    if self.model.playlist_jump(self.model.playlist_idx + delta):
      self.ui.set_iofn(self.model.playlist_idx + 1)
      self.set_app_state("PLAY")

  def on_destroy(self):
    self.model.set_player_state("STOP")  # should wait...
    self.ui.quit()

  def set_app_state(self, state):
    print "app_state", state
    if state == "PLAY" and self.timeout is None:
      print "timer started"
      self.timeout = self.ui.create_timer (1, self.update_ui)
    if state in ["PAUSE", "STOP"] and self.timeout is not None:
      print "timer stopped"
      self.ui.cancel_timer(self.timeout)
      self.timeout = None
    self.model.set_player_state(state)
    self.ui.set_ui_state(state)

player = PB2Player(prog_options, prog_args)
player.run()
